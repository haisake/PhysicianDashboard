x <- intersect(x,index)     #beyond UCL and post
pp$colour[x] <-"red"
pp$colourLab[x]<-"bad"
z <- which(pp$y < pp$lcl)  #beyond UCL
z <- intersect(z, index)     #beyond UCL and post
pp$colour[z] <-"forestgreen"
pp$colourLab[z]<-"good"
pp$colour
pp$colourLab
zG <- setdiff(spcIndexGood,z)
zB <-setdiff(spcIndexBad,x)
rm(list=ls())
connectionName <-"AISAKE-DSSI"
libPath <-"G:/VCHDecisionSupport/Patient Flow/Richmond RMarkdown Reports/Visibility Wall - Access and Flow/R Library"
wd <- "G:/VCHDecisionSupport/Patient Flow/Richmond RMarkdown Reports/Visibility Wall - Access and Flow"
queryFileName <-"pullIndicatorQuery.txt"
colMappingFileName <-"columnMapping.csv"
logFileName <- paste0(wd,"/SPC Logs/Historical Special Casuses ",format(Sys.time(), "%d %B %Y"),".csv")
histParaW  <<-4
histParaFP <<-2
#################################
## INITIALIZE
.libPaths(libPath) #set the library path
setwd(wd)   #set the work directory
source("./SourceFiles/sourceHeaderv2.R", local = TRUE) #loads additional files with custom user functions
loadPack()  #loads packages
data<-loadData(connectionName, queryFileName,colMappingFileName)
for(ii in 1:length(data)){
createChart(data[[ii]])
}
data[[1]]
utils::View(data[[1]])
##########################
#Purpose: To house functions necessary for generating the SPC charts
#Author: Hans Aisake
#Date Created: July 17, 2018
#Date Modified: August 13, 2018
#Comments:
##########################
#FUNCTION PURPOSE: To identify the main title text
chartTitle <-function(indicatorName,groupName, chartType)
{
#create chart titles
x<-list()
x$Main <-as.character(indicatorName)
x$Sub <- paste0(as.character(groupName), ":",toupper(chartType),"-Chart")
return(x)
}
#FUNCTION PURPOSE: Identify the chart type
chartType <-function(chartType)
{
return(as.character(chartType))
}
#FUNCTION PURPOSE: Identify vertical axis title
vTitle <-function(chartType , indicatorID)
{
if (chartType=="p" || indicatorID %in% c(3,9,10)){
x<-"Percentage %"
}else{
x<-"Value #"
}
return(x)
}
#FUNCTION PURPOSE: Identify  horizontal tick labels
hLabels <-function(dat)
{
l<-NULL #labels
if (length(dat$TimeFrameLabel)<=52){
l<-as.character(dat$TimeFrameLabel)
} else{
l <- rep("",length(dat$TimeFrameLabel))
index <-1:length(l) %% 52
ind_l <- which(index==index[length(index)])
l[ind_l]<-as.character(dat$TimeFrameLabel[ind_l])
#l[1]<-as.character(dat$TimeFrameLabel[1])
}
return(l)
}
#FUNCTION PURPOSE: Identify the desired direction of the metrics
dDirection <-function(dir)
{
if(dir=="Above"){
x <-1
} else if(dir=="Below"){
x<-0
} else{
x<-NA
}
return(x)
}
#FUNCTION PURPOSE: Set how many data points to include in the SPC chart calibration
setFreeze <- function(n)
{
weeklyFreeze <- 52*2
periodFreeze <- 13*2
if(periodFreeze<=n & n< weeklyFreeze){
x <- periodFreeze
}else if (n>weeklyFreeze ){
x <- weeklyFreeze
}else {
x<-NULL
}
return(x)
}
#FUNCTION PURPOSE: Create a list with middle and sigma needed for the SPC special cause detection rules function
rulesPara <- function(dat, cType){
#needed parameters on the clibration data
if(cType=="i"){
middle <-mean(dat$Value)
#x_med <-median(dat)
sigma <-sqrt(var(dat$Value))
} else if (cType=="p"){
middle <-sum(dat$Numerator)/sum(dat$Denominator)
#x_med <-median(dat$Numerator/dat$Denominator)
sigma <-sqrt(middle*(1-middle)/mean(dat$Denominator))
} else{
warning("Error Chart type not specified")
return(NULL)
}
x<-list(middle,sigma)
names(x)<-c("middle","sigma")
return(x)
}
#FUNCTION PURPOSE: Create a list with the chart parameters for easier plot construction
chartParameters <- function(dat)
{
#troubleshooting
#dat <-data[[17]]
para <-list()
indicatorID <-dat$indicatorID[1]
indicatorName<- dat$IndicatorName[1]
groupName <- dat$entity_group[1]
dir <-dat$DesiredDirection[1]
hTitle <- dat$TimeFrameType[1]
datasource <-as.character(dat$DataSource[1])
format <-dat$Format[1]
#identify chart type as a primary attribute of importance
chartType <-dat$ChartType[1]
#get rules parameters
rp <- rulesPara(dat,chartType)
#get chart titles
temp1 <-chartTitle(indicatorName, groupName, chartType)
#compute parameters, essentially formating and look ups
para[[length(para)+1]] <- getElement(temp1,"Main") #identify main title
para[[length(para)+1]] <- getElement(temp1,"Sub") #identifies sub title
para[[length(para)+1]] <- vTitle(chartType,dat$indicatorID[1])   #identify vertical title
para[[length(para)+1]] <- hTitle           #identify horizontal title
para[[length(para)+1]] <- hLabels(dat)      #labels
para[[length(para)+1]] <- dDirection(dir)         #identify desired direction
para[[length(para)+1]] <- chartType
para[[length(para)+1]] <- setFreeze(length(dat$Value))
para[[length(para)+1]] <- rp$middle
para[[length(para)+1]] <- rp$sigma
para[[length(para)+1]] <- datasource
para[[length(para)+1]] <- format
para[[length(para)+1]] <- dat$TimeFrameLabel
#assign names to the variables
names(para)<-c("Main","Sub","vTitle","hTitle","hLabels","dir","chartType","freeze","middle","sigma","datasource","format","fullHLabels")
return(para)
}
#for swapping the colours for the nelson rules additional colouring
colourSwap <- function(x)
{
y <- switch(x,"black"="yellow","gray80"="gray80","forestgreen"="forestgreen","red3"="red3")
return(y)
}
#for swapping the colours for the nelson rules additional colouring
colourSwapBad <- function(x)
{
y <- switch(x,"black"="salmon","gray80"="gray80","forestgreen"="forestgreen","red3"="red3")
return(y)
}
#for swapping the colours for the nelson rules additional colouring
colourSwapGood<- function(x)
{
y <- switch(x,"black"="darkolivegreen3","gray80"="gray80","forestgreen"="forestgreen","red3"="red3")
return(y)
}
# colourSwap2 <- function(x)
# {
#   y <- switch(x,"G"="forestgreen","B"="red3","U"="saddlebrown")
#   return(y)
# }
#for swapping the colour labels for the nelson rules additional colouring
colourLabSwap <- function(x)
{
y <- switch(x,"normal"="sp.pattern","baseline"="baseline","good"="good","bad"="bad")
#y <- switch(x,"black"="yellow","gray80"="gray80","forestgreen"="aquamarine","red3"="saddlebrown")
return(y)
}
#for swapping the colour labels for the nelson rules additional colouring
colourLabSwapGood <- function(x)
{
y <- switch(x,"normal"="sp.pattern.good","baseline"="baseline","good"="sp.pattern.good","bad"="bad")
#y <- switch(x,"black"="yellow","gray80"="gray80","forestgreen"="aquamarine","red3"="saddlebrown")
return(y)
}
colourLabSwapBad <- function(x)
{
y <- switch(x,"normal"="sp.pattern.bad","baseline"="baseline","good"="good","bad"="sp.pattern.bad")
#y <- switch(x,"black"="yellow","gray80"="gray80","forestgreen"="aquamarine","red3"="saddlebrown")
return(y)
}
#for swapping the colour labels for the nelson rules additional colouring
colourLabSwap2 <- function(x)
{
y <- switch(x,"G"="good","B"="bad","U"="unclear")
return(y)
}
#generate the SPC chart object using QICCharts2
generateQICChart <- function(dat,para)
{
#generate qic values: UCL, LCL, CL, etc....
if(para$chartType=="p"){
pp<-qic(x=TimeFrame, n=Denominator, y=Numerator, chart=para$chartType, freeze=para$freeze, data=dat, plot.chart=FALSE)       #computes UCL, LCL, CL, etc..
} else if(para$chartType=="i"){
pp<-qic(x=TimeFrame, y=Value, chart=para$chartType, freeze=para$freeze, data=dat, plot.chart=FALSE)       #computes UCL, LCL, CL, etc..
} else{
return(NULL)
}
return(pp)
}
#add point sizes
addSize <-function(pp)
{
#set points size
pp$size <-rep(2,length(pp$y))
pp$size[length(pp$y)]<-3
return(pp)
}
#add point sizes
addShapes<-function(pp,freeze)
{
#set points size
if(is.null(freeze)){
pp$shape <- rep(16,length(pp$y))
}else{
pp$shape <- c(rep(1,freeze),rep(16,length(pp$y)-freeze))
}
pp$shape[length(pp$y)]<-18
return(pp)
}
#add colours
addColour<-function(pp, spcPoints, para)
{
#set default colours: highlight calibration data and post data
pp$colour <- c(rep("gray80",para$freeze), rep("black", length(pp$y) - (para$freeze)))
pp$colourLab <- c(rep("baseline",para$freeze), rep("normal", length(pp$y) - (para$freeze)))
index <- (para$freeze+1):length(pp$y)
#
spcIndexBad <- spcPoints$ID[which(spcPoints$Status=="B")]
spcIndexGood <- spcPoints$ID[which(spcPoints$Status=="G")]
spcIndexUnknown <- spcPoints$ID[which(spcPoints$Status=="U")]
#change colour of the points in the desired direction beyond CL's
if( para$dir==1){
x <- which(pp$y > pp$ucl)  #beyond UCL
x <- intersect(x,index)     #beyond UCL and post
pp$colour[x] <-"forestgreen"
pp$colourLab[x] <-"good"
z <- which(pp$y < pp$lcl)  #beyond UCL
z <- intersect(z, index)     #beyond UCL and post
pp$colour[z] <-"red3"
pp$colourLab[z]<-"bad"
zG <- setdiff(spcIndexGood,x)
zB <-setdiff(spcIndexBad,z)
pp$colour[zG]<-as.character(sapply(pp$colour[zG] ,FUN=colourSwapGood))
pp$colourLab[zG]<-as.character(sapply(pp$colourLab[zG] ,FUN=colourLabSwapGood))
pp$colour[zB]<-as.character(sapply(pp$colour[zB] ,FUN=colourSwapBad))
pp$colourLab[zB]<-as.character(sapply(pp$colourLab[zB] ,FUN=colourLabSwapBad))
}else if( para$dir==0){
x <- which(pp$y > pp$ucl)  #beyond UCL
x <- intersect(x,index)     #beyond UCL and post
pp$colour[x] <-"red3"
pp$colourLab[x]<-"bad"
z <- which(pp$y < pp$lcl)  #beyond UCL
z <- intersect(z, index)     #beyond UCL and post
pp$colour[z] <-"forestgreen"
pp$colourLab[z]<-"good"
zG <- setdiff(spcIndexGood,z)
zB <-setdiff(spcIndexBad,x)
pp$colour[zG]<-as.character(sapply(pp$colour[zG] ,FUN=colourSwapGood))
pp$colourLab[zG]<-as.character(sapply(pp$colourLab[zG] ,FUN=colourLabSwapGood))
pp$colour[zB]<-as.character(sapply(pp$colour[zB] ,FUN=colourSwapBad))
pp$colourLab[zB]<-as.character(sapply(pp$colourLab[zB] ,FUN=colourLabSwapBad))
}
pp$colour[spcIndexUnknown] <-"saddlebrown"
pp$colourLab[spcIndexUnknown] <-"good & bad"
#assign colour for special cause detection points identified by the rule set
# if(is.not.null(spcPoints)){
#
#   ind<-as.numeric(spcPoints$ID)
#   pp$colour[ind]<-as.character(sapply(spcPoints$Status ,FUN=colourSwap2))
#   pp$colourLab[ind] <-as.character(sapply(spcPoints$Status ,FUN=colourLabSwap2))
# }
#last points colour
pp$colour[length(pp$colour)] <-"dodgerblue3"
pp$colourLab[length(pp$colour)] <-"latest"
return(pp)
}
#######################################
##Generate the SPC charts
#######################################
createChart <- function(dat)
{
#trouble shooting
#dat<-data[[1]]
#generate chart parameters
para <-chartParameters(dat)
annFontSize<-3
#generate the CL, LCL, and UCL
pp<-generateQICChart(dat,para)
#identify sub data set
index <- (para$freeze+1):length(pp$y)
#subDat <-dat[index,]
#run SPC Chart rules on the data
patterns<-findAllPatterns(val=pp$y[index], ucl=pp$ucl[index], lcl=pp$lcl[index],mu=para$middle, sigma=para$sigma, para$dir, labs=para$fullHLabels[index], tfType=para$hTitle)
spcPoints <- patterns$spcPoints
spcPoints$ID <- spcPoints$ID + para$freeze
appendixMSG <- patterns$appendixMSG
summaryMSG <- patterns$summaryMSG
recentOutlier <-patterns$currentOutlierFlag
#add additoinal attributes
pp<-addSize(pp)
pp<-addShapes(pp, para$freeze)
pp<-addColour(pp, spcPoints, para)
#generate the ggplot object
#transform the QIC list like object into a data frame
p <-data.frame(x =1:length(pp$y), y=pp$y,u=pp$ucl,l=pp$lcl, cl=pp$cl, c=pp$colour,c_lab=pp$colourLab, hl=para$hLabels, s=pp$size, sh=pp$shape)
#####
#set up the ggplot object
#populate the plot with the points
#populate the UCL
#populate the LCL
#set the tick marks
#set the theme for the background and grid line appearances
#hide the legend
#set the colour of the points
#add titles and axis labels
#add annotations for the CL, UCL, and LCL
#####
bInd<-which(sapply(para$hLabels,FUN=nchar)>0)
if(para$chartType=="p" | dat$indicatorID[1] %in% c(3,9,10)){
symb<-"%"
scaleFactor <- 100
prec <- as.numeric(substr(para$format,2,2))+2
labShiftFactor <-0.05*para$middle
}else{
symb<-""
scaleFactor<-1
prec <- as.numeric(substr(para$format,2,2))
labShiftFactor <-0
}
#text for the CL annotations
clTxt <-paste0("CL ",round(para$middle,prec)*scaleFactor,symb)
uclTxt <-paste0("UCL ",round(p$u[length(p$u)],prec)*scaleFactor,symb)
lclTxt <-paste0("LCL ",round(p$l[length(p$l)],prec)*scaleFactor,symb)
#x location for the CL annotations
shift_loc <-max(5,round(para$freeze/10,0))
#create the plot
p2<- ggplot(data=p,aes(x, y, colour=c))+
geom_point(aes(y=y,colour=c,shape=sh, size=s))+
scale_shape_identity()+
scale_size_identity() +
geom_line(aes(x,cl), colour="black", linetype=5)+
geom_line(aes(x,u), colour="grey50", linetype=3)+
geom_line(aes(x,l), colour="grey50", linetype=3) +
scale_x_continuous(breaks=bInd,labels=para$hLabels[bInd]) +
theme_bw() +
theme(plot.caption=element_text(margin=margin(t=0),face="italic", size=8)) +
theme( panel.grid.minor = element_blank(), axis.text.x = element_text(angle = 90, vjust=0.5)) +
scale_colour_identity("Status",guide="legend", breaks=unique(p$c), labels=unique(p$c_lab)) +
labs(x=para$hTitle, y=para$vTitle, title=para$Main, subtitle=para$Sub, caption=paste0("labels are rounded; Data Source:",para$datasource)) +
annotate("text",label=clTxt, x=shift_loc,y=para$middle+labShiftFactor,colour="black", size=annFontSize, fontface = "bold")+
annotate("text",label=uclTxt,x=shift_loc,y=p$u[length(p$u)]+labShiftFactor ,colour="black",size=annFontSize, fontface = "bold")+
annotate("text",label=lclTxt,x=shift_loc,y=p$l[length(p$l)]+labShiftFactor ,colour="black",size=annFontSize, fontface = "bold")
#scale the y-axis where appropriate for percentages
if(para$chartType=="p" | dat$indicatorID[1] %in% c(3,9,10)){
yl <- c(floor(max(0,.9*min(pp$y,pp$lcl))*100)/100, ceiling(min(1,max(pp$y,pp$ucl)*1.1)*100)/100)
p2<- p2+scale_y_continuous(labels =function(x) 100*x, limits=yl)
}
#
if(is.not.null(summaryMSG) | recentOutlier==TRUE ){
shortVersionInclusion <- TRUE
}else{
shortVersionInclusion <- FALSE
}
#return the plot, the historical special cause messages, and the summary special cause messages
result <- list(p2,appendixMSG,summaryMSG,as.character(dat$IndicatorName[1]),as.character(dat$entity_group[1]), shortVersionInclusion)
names(result) <-c("plot","appendixMSG","summaryMSG","indicatorName","entity_group","shortVersionInclusion")
return(result)
}
dat<-data[[1]]
para <-chartParameters(dat)
annFontSize<-3
pp<-generateQICChart(dat,para)
index <- (para$freeze+1):length(pp$y)
patterns<-findAllPatterns(val=pp$y[index], ucl=pp$ucl[index], lcl=pp$lcl[index],mu=para$middle, sigma=para$sigma, para$dir, labs=para$fullHLabels[index], tfType=para$hTitle)
spcPoints <- patterns$spcPoints
spcPoints$ID <- spcPoints$ID + para$freeze
appendixMSG <- patterns$appendixMSG
summaryMSG <- patterns$summaryMSG
recentOutlier <-patterns$currentOutlierFlag
pp<-addSize(pp)
pp<-addShapes(pp, para$freeze)
pp<-addColour(pp, spcPoints, para)
dat$Target
pp$y
para$freeze
?geom_line
names(pp)
?geom_line
tarDat <- data.frame(x=para$freeze:length(p$y)],t=dat$Target[para$freeze:length(p$y)])
tarDat <- data.frame(x=para$freeze:length(p$y),t=dat$Target[para$freeze:length(p$y)])
tarDat <- data.frame(x=para$freeze:length(pp$y),t=dat$Target[para$freeze:length(pp$y)])
tarDat
p <-data.frame(x =1:length(pp$y), y=pp$y,u=pp$ucl,l=pp$lcl, cl=pp$cl, c=pp$colour,c_lab=pp$colourLab, hl=para$hLabels, s=pp$size, sh=pp$shape)
bInd<-which(sapply(para$hLabels,FUN=nchar)>0)
if(para$chartType=="p" | dat$indicatorID[1] %in% c(3,9,10)){
symb<-"%"
scaleFactor <- 100
prec <- as.numeric(substr(para$format,2,2))+2
labShiftFactor <-0.05*para$middle
}else{
symb<-""
scaleFactor<-1
prec <- as.numeric(substr(para$format,2,2))
labShiftFactor <-0
}
clTxt <-paste0("CL ",round(para$middle,prec)*scaleFactor,symb)
uclTxt <-paste0("UCL ",round(p$u[length(p$u)],prec)*scaleFactor,symb)
lclTxt <-paste0("LCL ",round(p$l[length(p$l)],prec)*scaleFactor,symb)
shift_loc <-max(5,round(para$freeze/10,0))
ggplot(data=p,aes(x, y, colour=c))+
geom_point(aes(y=y,colour=c,shape=sh, size=s))+
scale_shape_identity()+
scale_size_identity() +
geom_line(aes(x,cl), colour="black", linetype=5)+
geom_line(aes(x,u), colour="grey50", linetype=3)+
geom_line(aes(x,l), colour="grey50", linetype=3) +
geom_line(data=tarDat, aes(x,t), colour="blue", linetype=3)
p2<- ggplot(data=p,aes(x, y, colour=c))+
geom_point(aes(y=y,colour=c,shape=sh, size=s))+
scale_shape_identity()+
scale_size_identity() +
geom_line(aes(x,cl), colour="black", linetype=5)+
geom_line(aes(x,u), colour="grey50", linetype=3)+
geom_line(aes(x,l), colour="grey50", linetype=3) +
geom_line(data=tarDat, aes(x,t), colour="blue", linetype=3) +
scale_x_continuous(breaks=bInd,labels=para$hLabels[bInd]) +
theme_bw() +
theme(plot.caption=element_text(margin=margin(t=0),face="italic", size=8)) +
theme( panel.grid.minor = element_blank(), axis.text.x = element_text(angle = 90, vjust=0.5)) +
scale_colour_identity("Status",guide="legend", breaks=unique(p$c), labels=unique(p$c_lab)) +
labs(x=para$hTitle, y=para$vTitle, title=para$Main, subtitle=para$Sub, caption=paste0("labels are rounded; Data Source:",para$datasource)) +
annotate("text",label=clTxt, x=shift_loc,y=para$middle+labShiftFactor,colour="black", size=annFontSize, fontface = "bold")+
annotate("text",label=uclTxt,x=shift_loc,y=p$u[length(p$u)]+labShiftFactor ,colour="black",size=annFontSize, fontface = "bold")+
annotate("text",label=lclTxt,x=shift_loc,y=p$l[length(p$l)]+labShiftFactor ,colour="black",size=annFontSize, fontface = "bold")
ggplot(data=p,aes(x, y, colour=c))+
geom_point(aes(y=y,colour=c,shape=sh, size=s))+
scale_shape_identity()+
scale_size_identity() +
geom_line(aes(x,cl), colour="black", linetype=5)+
geom_line(aes(x,u), colour="grey50", linetype=3)+
geom_line(aes(x,l), colour="grey50", linetype=6) +
geom_line(data=tarDat, aes(x,t), colour="blue", linetype=3) +
scale_x_continuous(breaks=bInd,labels=para$hLabels[bInd]) +
theme_bw() +
theme(plot.caption=element_text(margin=margin(t=0),face="italic", size=8)) +
theme( panel.grid.minor = element_blank(), axis.text.x = element_text(angle = 90, vjust=0.5)) +
scale_colour_identity("Status",guide="legend", breaks=unique(p$c), labels=unique(p$c_lab)) +
labs(x=para$hTitle, y=para$vTitle, title=para$Main, subtitle=para$Sub, caption=paste0("labels are rounded; Data Source:",para$datasource)) +
annotate("text",label=clTxt, x=shift_loc,y=para$middle+labShiftFactor,colour="black", size=annFontSize, fontface = "bold")+
annotate("text",label=uclTxt,x=shift_loc,y=p$u[length(p$u)]+labShiftFactor ,colour="black",size=annFontSize, fontface = "bold")+
annotate("text",label=lclTxt,x=shift_loc,y=p$l[length(p$l)]+labShiftFactor ,colour="black",size=annFontSize, fontface = "bold")
######################
connectionName <-"AISAKE-DSSI"
libPath <-"G:/VCHDecisionSupport/Patient Flow/Richmond RMarkdown Reports/Visibility Wall - Access and Flow/R Library"
wd <- "G:/VCHDecisionSupport/Patient Flow/Richmond RMarkdown Reports/Visibility Wall - Access and Flow"
queryFileName <-"pullIndicatorQuery.txt"
colMappingFileName <-"columnMapping.csv"
logFileName <- paste0(wd,"/SPC Logs/Historical Special Casuses ",format(Sys.time(), "%d %B %Y"),".csv")
histParaW  <<-4
histParaFP <<-2
#################################
## INITIALIZE
.libPaths(libPath) #set the library path
setwd(wd)   #set the work directory
source("./SourceFiles/sourceHeaderv2.R", local = TRUE) #loads additional files with custom user functions
loadPack()  #loads packages
connectionName <-"AISAKE-DSSI"
libPath <-"G:/VCHDecisionSupport/Patient Flow/Richmond RMarkdown Reports/Visibility Wall - Access and Flow/R Library"
wd <- "G:/VCHDecisionSupport/Patient Flow/Richmond RMarkdown Reports/Visibility Wall - Access and Flow"
queryFileName <-"pullIndicatorQuery.txt"
colMappingFileName <-"columnMapping.csv"
logFileName <- paste0(wd,"/SPC Logs/Historical Special Casuses ",format(Sys.time(), "%d %B %Y"),".csv")
histParaW  <<-4
histParaFP <<-2
#################################
## INITIALIZE
.libPaths(libPath) #set the library path
setwd(wd)   #set the work directory
source("./SourceFiles/sourceHeaderv2.R", local = TRUE) #loads additional files with custom user functions
loadPack()  #loads packages
utils::View(data)
rm(list=ls())
rm(list=ls())
#set library and working directories
libPath <-"H:/Hans/R Libraries"
.libPaths(libPath) #set the library path
wd <- "//vch.ca/departments/VCHDecisionSupport/Patient Flow/Richmond SSRS Reports/PhysicianDashboard/PhysicianDashboard/src"
setwd(wd)
library(RODBC)
